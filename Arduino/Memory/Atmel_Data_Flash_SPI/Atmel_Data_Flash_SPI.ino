/*  Author  - Ankur Maurya
    Created - 19 April 2021

    Program for Reading/Writing to Atmel Flash Memory (AT45DB011B)
    1 Megabit ~ 132 KB of Memory Space

    Note: Use 101pf Capacitor between +Vcc and -Ground pin to make the programming on chip to work correctly
          as the erase operation on chip require stable voltage supply, which can be powered by capacitor.

*/

#include <SPI.h>


//  const byte fileData[] PROGMEM  = {0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
//                                    0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x42, 0x55, 0x49, 0x4C, 0x44, 0x20, 0x4F,
//                                    0x55, 0x54, 0x50, 0x55, 0x54, 0x20, 0x44, 0x45, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x49, 0x4F,
//                                    0x4E, 0x0A, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D,
//                                    0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x3D, 0x0A, 0x0A, 0x57, 0x68, 0x65, 0x6E,
//                                    0x20, 0x79, 0x6F, 0x75, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x4A, 0x61,
//                                    0x76, 0x61, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x70,
//                                    0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20,
//                                    0x61, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x2C, 0x20, 0x74, 0x68,
//                                    0x65, 0x20, 0x49, 0x44, 0x45, 0x0A, 0x61, 0x75, 0x74, 0x6F, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x61,
//                                    0x6C, 0x6C, 0x79, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F,
//                                    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x41, 0x52, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20,
//                                    0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x20,
//                                    0x63, 0x6C, 0x61, 0x73, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x79, 0x6F, 0x75,
//                                    0x72, 0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x20, 0x64, 0x69, 0x73, 0x74, 0x2F,
//                                    0x6C, 0x69, 0x62, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20,
//                                    0x49, 0x44, 0x45, 0x0A, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x61, 0x64, 0x64, 0x73, 0x20, 0x65, 0x61,
//                                    0x63, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x41, 0x52, 0x20, 0x66, 0x69,
//                                    0x6C, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73,
//                                    0x2D, 0x50, 0x61, 0x74, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E,
//                                    0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E,
//                                    0x0A, 0x4A, 0x41, 0x52, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x66,
//                                    0x65, 0x73, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x4D, 0x41, 0x4E, 0x49, 0x46, 0x45,
//                                    0x53, 0x54, 0x2E, 0x4D, 0x46, 0x29, 0x2E, 0x0A, 0x0A, 0x54, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x20,
//                                    0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D,
//                                    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E,
//                                    0x65, 0x2C, 0x20, 0x67, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73,
//                                    0x74, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x0A, 0x74, 0x79, 0x70,
//                                    0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x3A,
//                                    0x0A, 0x0A, 0x6A, 0x61, 0x76, 0x61, 0x20, 0x2D, 0x6A, 0x61, 0x72, 0x20, 0x22, 0x53, 0x6D, 0x61,
//                                    0x6C, 0x6C, 0x4A, 0x61, 0x76, 0x61, 0x2E, 0x6A, 0x61, 0x72, 0x22, 0x20, 0x0A, 0x0A, 0x54, 0x6F,
//                                    0x20, 0x64, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73,
//                                    0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x2C, 0x20, 0x7A, 0x69, 0x70, 0x20, 0x75, 0x70,
//                                    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72,
//                                    0x20, 0x28, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20,
//                                    0x6C, 0x69, 0x62, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x29, 0x0A, 0x61, 0x6E, 0x64, 0x20,
//                                    0x64, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x5A,
//                                    0x49, 0x50, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x0A, 0x0A, 0x4E, 0x6F, 0x74, 0x65, 0x73, 0x3A,
//                                    0x0A, 0x0A, 0x2A, 0x20, 0x49, 0x66, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x4A, 0x41, 0x52, 0x20, 0x66,
//                                    0x69, 0x6C, 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6A,
//                                    0x65, 0x63, 0x74, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x68, 0x61,
//                                    0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65,
//                                    0x2C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74,
//                                    0x0A, 0x4A, 0x41, 0x52, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 0x70,
//                                    0x69, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x62, 0x20, 0x66,
//                                    0x6F, 0x6C, 0x64, 0x65, 0x72, 0x2E, 0x0A, 0x2A, 0x20, 0x4F, 0x6E, 0x6C, 0x79, 0x20, 0x4A, 0x41,
//                                    0x52, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x70, 0x69,
//                                    0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x69, 0x62, 0x20, 0x66, 0x6F,
//                                    0x6C, 0x64, 0x65, 0x72, 0x2E, 0x0A, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6C, 0x61,
//                                    0x73, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20,
//                                    0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x66,
//                                    0x69, 0x6C, 0x65, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x66, 0x6F, 0x6C, 0x64, 0x65, 0x72, 0x73, 0x2C,
//                                    0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x28, 0x66, 0x6F,
//                                    0x6C, 0x64, 0x65, 0x72, 0x73, 0x29, 0x0A, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63,
//                                    0x6F, 0x70, 0x69, 0x65, 0x64, 0x2E, 0x0A, 0x2A, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x6C, 0x69,
//                                    0x62, 0x72, 0x61, 0x72, 0x79, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F,
//                                    0x6A, 0x65, 0x63, 0x74, 0x73, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20,
//                                    0x61, 0x6C, 0x73, 0x6F, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73,
//                                    0x2D, 0x50, 0x61, 0x74, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x0A, 0x73, 0x70,
//                                    0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D,
//                                    0x61, 0x6E, 0x69, 0x66, 0x65, 0x73, 0x74, 0x2C, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74,
//                                    0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73,
//                                    0x2D, 0x50, 0x61, 0x74, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x68, 0x61,
//                                    0x73, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x0A, 0x74, 0x68, 0x65, 0x20, 0x70,
//                                    0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x20, 0x72, 0x75, 0x6E, 0x74, 0x69, 0x6D, 0x65, 0x20,
//                                    0x70, 0x61, 0x74, 0x68, 0x2E, 0x0A, 0x2A, 0x20, 0x54, 0x6F, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61,
//                                    0x20, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61,
//                                    0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x20, 0x4A, 0x61, 0x76, 0x61, 0x20, 0x70,
//                                    0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x2C, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x2D, 0x63, 0x6C,
//                                    0x69, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x20,
//                                    0x6E, 0x6F, 0x64, 0x65, 0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x50, 0x72, 0x6F, 0x6A,
//                                    0x65, 0x63, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x64, 0x20,
//                                    0x63, 0x68, 0x6F, 0x6F, 0x73, 0x65, 0x20, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65,
//                                    0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x69, 0x63, 0x6B, 0x20, 0x52, 0x75,
//                                    0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x0A,
//                                    0x63, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68,
//                                    0x65, 0x20, 0x4D, 0x61, 0x69, 0x6E, 0x20, 0x43, 0x6C, 0x61, 0x73, 0x73, 0x20, 0x66, 0x69, 0x65,
//                                    0x6C, 0x64, 0x2E, 0x20, 0x41, 0x6C, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x6C,
//                                    0x79, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x6D, 0x61, 0x6E, 0x75, 0x61,
//                                    0x6C, 0x6C, 0x79, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 0x65, 0x0A, 0x63, 0x6C, 0x61,
//                                    0x73, 0x73, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D,
//                                    0x61, 0x6E, 0x69, 0x66, 0x65, 0x73, 0x74, 0x20, 0x4D, 0x61, 0x69, 0x6E, 0x2D, 0x43, 0x6C, 0x61,
//                                    0x73, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x0D, 0x0A
//                                   };




#define MAIN_MEMORY_PAGES 512
#define MAIN_MEMORY_PAGE_SIZE 264
#define MEMORY_BUFFER_SIZE 264
#define MEMORY_SIZE 135168  // --- 132 KB

#define STATUS_REG_OPCODE 0xD7 //11010111
#define PAGE_ERASE_OPCODE 0x81 //10000001
#define CONTINUOUS_ARRAY_READ_OPCODE 0xE8 //11101000
#define MAIN_MEMORY_PAGE_READ_OPCODE 0xD2 //11010010
#define BUFFER_READ_OPCODE 0xD4 //11010100

#define BUFFER_WRITE_OPCODE 0x84 //10000100
#define BUFFER_TO_MAIN_MEMORY_WRITE_WITH_ERASE_OPCODE 0x83  //10000011
#define BUFFER_TO_MAIN_MEMORY_WRITE_WITHOUT_ERASE_OPCODE 0x88  //10001000
#define MAIN_MEMORY_PAGE_PROGRAM_THROUGH_BUFFER_OPCODE 0x82 //10000010


#define CS_PIN 10

byte pageData[MAIN_MEMORY_PAGE_SIZE];

void readStatusRegister() {
  byte statReg;

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(STATUS_REG_OPCODE);
  statReg = SPI.transfer(0x00);
  digitalWrite(CS_PIN, HIGH); // set CS inactive

  Serial.print("Status Register - "); //Print statement
  Serial.println(statReg, BIN); //Print statement
}

boolean isDeviceReady() {
  byte statReg;
  byte compOffset = B00000001;

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(STATUS_REG_OPCODE);
  statReg = SPI.transfer(0x00);
  digitalWrite(CS_PIN, HIGH); // set CS inactive

  return (((statReg >> 7) & compOffset) == compOffset);
}

void waitUntilDeviceIsReady() {
  //Wait in the loop until the device is ready
  while (!isDeviceReady) {
    delay(10);
  }
}

void continuousArrayRead() {
  byte dataByte[MEMORY_SIZE];
  byte data;

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(CONTINUOUS_ARRAY_READ_OPCODE);

  SPI.transfer(0x00); //24 bit page address
  SPI.transfer(0x00);
  SPI.transfer(0x00);

  SPI.transfer(0x00); //32 don't care bits
  SPI.transfer(0x00);
  SPI.transfer(0x00);
  SPI.transfer(0x00);

  Serial.println("------- CONTINUOUS ARRAY READ --------"); //Print statement
  int lineCntr = 0;
  for (int i = 0; i < MEMORY_SIZE; i++) {
    if (lineCntr == 8) {
      Serial.print(i, DEC); //Print statement
      Serial.println("");
      lineCntr = 0;
    }

    data = SPI.transfer(0x00);
    Serial.print(data, BIN); //Print statement
    Serial.print(" ");
    lineCntr++;
  }

  digitalWrite(CS_PIN, HIGH); // set CS inactive

  Serial.println("");
}

void pageErase(uint16_t page) {
  uint16_t pageBuff = 0x00;

  Serial.print("Erasing Page : ");
  Serial.println(page, DEC);

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(PAGE_ERASE_OPCODE);

  //24 bit page address
  SPI.transfer(page >> (16 - 9));
  SPI.transfer((page << (9  - 8)) | (uint8_t)(pageBuff >> 8));
  SPI.transfer(pageBuff & 0xff);

  digitalWrite(CS_PIN, HIGH); // set CS inactive
  waitUntilDeviceIsReady(); //Poll the status register and wait till the device is busy
  Serial.println("Done");
}

void memoryErase() {
  uint16_t pageNumber = 0x00;

  for (int i = 0; i < MAIN_MEMORY_PAGES; i++) {
    pageErase(pageNumber);
    pageNumber++;
  }
}

void pageRead(uint16_t page, uint16_t pageBuff, boolean logEnabled) {
  if (logEnabled) {
    Serial.print("Reading Page : ");
    Serial.println(page, DEC);
  }

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(MAIN_MEMORY_PAGE_READ_OPCODE);

  //24 bit page address
  SPI.transfer(page >> (16 - 9));
  SPI.transfer((page << (9  - 8)) | (uint8_t)(pageBuff >> 8));
  SPI.transfer(pageBuff & 0xff);

  //32 don't care bits
  SPI.transfer(0x00);
  SPI.transfer(0x00);
  SPI.transfer(0x00);
  SPI.transfer(0x00);

  for (int i = 0; i < MAIN_MEMORY_PAGE_SIZE; i++)
  {
    pageData[i] = SPI.transfer(0xff);
  }

  digitalWrite(CS_PIN, HIGH); // set CS inactive
  waitUntilDeviceIsReady(); //Poll the status register and wait till the device is busy
}

void printPage(uint16_t page, boolean logEnabled) {

  pageRead(page, 0, logEnabled); //First read page contents in page data buffer

  //Print Data
  for (int i = 0; i < MAIN_MEMORY_PAGE_SIZE; i++) {
    //Serial.print((char)pageData[i]); //Print statement
    Serial.write(pageData[i]); //Print statement
  }

  //  int lineCntr = 0;
  //  for (int i = 0; i < MAIN_MEMORY_PAGE_SIZE; i++) {
  //    if (lineCntr == 8) {
  //      Serial.println("");
  //      lineCntr = 0;
  //    }
  //
  //    Serial.print(pageData[i], BIN); //Print statement
  //    Serial.print(" ");
  //    lineCntr++;
  //  }
  //  Serial.println("");
}

boolean verifyPageContents(uint16_t page, byte dataBuffer[]) {
  boolean dataMatched = true;
  Serial.print("Verifying Page ");
  Serial.print(page, DEC);
  Serial.println(" Data with Buffer Data");

  pageRead(page, 0, false); //First read page contents in page data buffer

  for (int i = 0; i < MAIN_MEMORY_PAGE_SIZE; i++) {
    if (pageData[i] != dataBuffer[i]) {
      dataMatched = false;
      break;
    }
  }
  return dataMatched;
}


void printAllMemoryPages() {
  uint16_t pageNumber = 0x00;
  for (int i = 0; i < MAIN_MEMORY_PAGES; i++) {
    printPage(pageNumber, false);
    pageNumber++;
  }
}

void bufferRead(uint16_t pageBuff) {
  byte bufferData[MEMORY_BUFFER_SIZE];

  Serial.println("Reading Data from Buffer......."); //Print statement

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(BUFFER_READ_OPCODE);

  //24 bit buffer address
  SPI.transfer(0x00);
  SPI.transfer((pageBuff >> 8));
  SPI.transfer(pageBuff & 0xff);

  //8 don't care bits
  SPI.transfer(0x00);

  for (int i = 0; i < MEMORY_BUFFER_SIZE; i++)
  {
    bufferData[i] = SPI.transfer(0xff);
  }

  digitalWrite(CS_PIN, HIGH); // set CS inactive

  //Print Data
  for (int i = 0; i < MEMORY_BUFFER_SIZE; i++) {
    Serial.print((char)bufferData[i]); //Print statement
  }
  Serial.println("");
}

void bufferWrite(uint16_t pageBuff, byte dataBuffer[]) {
  uint16_t page = 0;

  Serial.println("Writing Data to Buffer......."); //Print statement

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(BUFFER_WRITE_OPCODE);

  //24 bit buffer address
  SPI.transfer(0x00);
  SPI.transfer(pageBuff >> 8);
  SPI.transfer(pageBuff & 0xff);

  for (int i = 0; i < MEMORY_BUFFER_SIZE; i++)
  {
    SPI.transfer(dataBuffer[i]);
  }

  digitalWrite(CS_PIN, HIGH); // set CS inactive
  waitUntilDeviceIsReady(); //Poll the status register and wait till the device is busy

  Serial.println("Data Written to Buffer."); //Print statement
}

void bufferToMainMemoryWriteWithBuiltInErase(uint16_t page, byte dataBuffer[]) {
  uint16_t pageBuff = 0;

  Serial.print("Writing Buffer to Page : ");
  Serial.println(page, DEC);

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(BUFFER_TO_MAIN_MEMORY_WRITE_WITH_ERASE_OPCODE);

  //24 bit page address
  SPI.transfer(page >> (16 - 9));
  SPI.transfer((page << (9  - 8)) | (uint8_t)(pageBuff >> 8));
  SPI.transfer(pageBuff & 0xff);

  digitalWrite(CS_PIN, HIGH); // set CS inactive
  waitUntilDeviceIsReady(); //Poll the status register and wait till the device is busy
}


void bufferToMainMemoryWriteWithoutBuiltInErase(uint16_t page, byte dataBuffer[]) {
  uint16_t pageBuff = 0;

  Serial.print("Writing Buffer to Page : ");
  Serial.println(page, DEC);

  digitalWrite(CS_PIN, LOW);  // set CS active
  SPI.transfer(BUFFER_TO_MAIN_MEMORY_WRITE_WITHOUT_ERASE_OPCODE);

  //24 bit page address
  SPI.transfer(page >> (16 - 9));
  SPI.transfer((page << (9  - 8)) | (uint8_t)(pageBuff >> 8));
  SPI.transfer(pageBuff & 0xff);

  digitalWrite(CS_PIN, HIGH); // set CS inactive
  waitUntilDeviceIsReady(); //Poll the status register and wait till the device is busy
}


boolean writeToMemoryThroughBufferWithAutoErase(uint16_t page, byte dataBuffer[], int retryCnt) {
  Serial.println();
  //BUFFER WRITE
  bufferWrite(0, dataBuffer);
  delay(300);

  //BUFFER TO MAIN MEMORY WRITE WITH AUTO ERASE
  bufferToMainMemoryWriteWithBuiltInErase(page, dataBuffer);
  delay(200);

  if (verifyPageContents(page, dataBuffer)) {
    Serial.println("Verify - Success");
    return true;
  } else {
    Serial.println("Verify - Failed");
    return false;
  }
  Serial.println();
}


boolean writeToMemoryThroughBufferWithManualErase(uint16_t page, byte dataBuffer[], int retryCnt) {
  Serial.println();

  //PAGE ERASE
  pageErase(page);

  //BUFFER WRITE
  bufferWrite(0, dataBuffer);

  //BUFFER TO MAIN MEMORY WRITE WITHOUT AUTO ERASE
  bufferToMainMemoryWriteWithoutBuiltInErase(page, dataBuffer);

  if (verifyPageContents(page, dataBuffer)) {
    Serial.println("Verify - Success");
    return true;
  } else {
    Serial.println("Verify - Failed");
    if(retryCnt == 0){
      return false;
    }else{
      retryCnt--;
      delay(200*(50-retryCnt));
      writeToMemoryThroughBufferWithManualErase(page, dataBuffer, retryCnt);
    }
    
  }
  Serial.println();
}



void printBits(byte myByte) {
  for (byte mask = 0x80; mask; mask >>= 1) {
    if (mask & myByte)
      Serial.print('1');
    else Serial.print('0');
  }
}

boolean saveToMemory() {
  uint16_t pageBuff = 0;
  int retryCnt = 50;
  long memoryBytes = MEMORY_SIZE;
  uint16_t pageCntr = 0;
  uint16_t bufferCntr = 0;
  byte bufferData[MEMORY_BUFFER_SIZE];
  byte saveVal = 0;
  boolean pageWriteSuccess = true;
  boolean allPageWriteVerifiedSuccess = true;

  long i;
  for (i = 0; i < memoryBytes; i++) {
    if (bufferCntr == 264) {
      Serial.print("Writing Page - ");
      Serial.println(pageCntr, DEC);
      Serial.print("Counter - ");
      Serial.println(i, DEC);

      if (!verifyPageContents(pageCntr, bufferData)) {
        Serial.print("Page Contents not Matched ");
        Serial.println(pageCntr, DEC);
        pageWriteSuccess = writeToMemoryThroughBufferWithManualErase(pageCntr, bufferData, retryCnt);
      } else {
        Serial.print("Page Contents Matched ");
        Serial.println(pageCntr, DEC);
        Serial.println("");
      }

      if (!pageWriteSuccess) {
        allPageWriteVerifiedSuccess = false;
      }
      pageCntr++;
      bufferCntr = 0;
      saveVal++;
    }

    if (pageCntr == 256) {
      saveVal = 0;
    }


    if (pageCntr > 255) {
      bufferData[bufferCntr] =  255 - saveVal; //pgm_read_byte_near(fileData + i);
    } else {
      bufferData[bufferCntr] =  saveVal; //pgm_read_byte_near(fileData + i);
    }
    bufferCntr++;
  }

  if (pageWriteSuccess && bufferCntr > 0 && bufferCntr < 264) {
    for (int j = bufferCntr; j < 264; j++) {
      bufferData[j] = 0xFF;
      bufferCntr++;
    }
  }

  if (pageWriteSuccess && bufferCntr == 264) {
    Serial.print("Writing Page - ");
    Serial.println(pageCntr, DEC);
    Serial.print("Counter - ");
    Serial.println(i, DEC);

    if (!verifyPageContents(pageCntr, bufferData)) {
      Serial.print("Page Contents not Matched");
      Serial.println(pageCntr, DEC);
      pageWriteSuccess = writeToMemoryThroughBufferWithManualErase(pageCntr, bufferData, retryCnt);
    } else {
      Serial.print("Page Contents Matched");
      Serial.println(pageCntr, DEC);
      Serial.println("");
    }

    if (!pageWriteSuccess) {
      allPageWriteVerifiedSuccess = false;
    }
    pageCntr++;
    bufferCntr = 0;
    saveVal++;
  }

  return allPageWriteVerifiedSuccess;
}

void printBuffer(uint16_t pageCntr, byte bufferData[]) {
  Serial.print("Printing Page - ");
  Serial.println(pageCntr, DEC);

  for (int k = 0; k < 264; k++) {
    Serial.print((char)bufferData[k]);
  }
  Serial.println();
}


void setup() {
  SPI.begin();

  //Declare SPI Data Pins
  pinMode(10, OUTPUT);
  pinMode(11, OUTPUT); //MOSI
  pinMode(13, OUTPUT); //SCK
  pinMode(12, INPUT); //MISO

  //Initialize SPI Pins
  digitalWrite(13, LOW); //SCK
  digitalWrite(11, LOW); //MOSI
  digitalWrite(10, HIGH); // set CS inactive

  //Begin SPI Communication
  SPI.beginTransaction (SPISettings (2000000, MSBFIRST, SPI_MODE3));

  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB
  }

  delay(20000);
  readStatusRegister();

  //------- PAGE ERASE AND PAGE READ
  //uint16_t pageNumber = 498;
  //pageErase(pageNumber);
  //delay(5000);
  //pageRead(pageNumber, 0);

  //------- BUFFER WRITE AND BUFFER READ
  //    byte dataBuffer[264];
  //    const char* dummyMessage = "Cll 4 phone3 on my account received a text message this morning from 1(410) 100-001 with a link to a YouTube page. None of us clicked on the link but I went on YouTube to see if I can find what this was and it appears to be a darn political ad talking about how if";
  //    for (int i = 0; dummyMessage[i] != '\0'; i++)
  //    {
  //      dataBuffer[i] = dummyMessage[i];
  //    }
  //
  //    bufferRead(0);
  //    bufferWrite(0, dataBuffer);
  //    bufferRead(0);

  //BUFFER WRITE TO MAIN MEMORY WRITE
  //  Serial.println("Writing Data to Main Memory........"); //Print statement
  //  bufferToMainMemoryWriteWithBuiltInErase(400, dataBuffer);
  //  bufferToMainMemoryWriteWithBuiltInErase(449, dataBuffer);
  //  bufferToMainMemoryWriteWithBuiltInErase(335, dataBuffer);
  //  bufferToMainMemoryWriteWithBuiltInErase(360, dataBuffer);
  //  delay(5000);
  //  Serial.println("Data Written to Main Memory."); //Print statement
  //  printPage(400);
  //  printPage(449);
  //  printPage(335);
  //  printPage(360);

  //ERASE ALL PAGES IN MEMORY
  //memoryErase();
  //delay(5000);

  //Read the Whole Memory
  //continuousArrayRead();

  //Read All Pages in Memory
  //printAllMemoryPages();

  //WRITE TO MAIN MEMORY THROUGH BUFFER
  //writeToMemoryThroughBuffer(50, dataBuffer, 40);
  //writeToMemoryThroughBuffer(138, dataBuffer, true);
  //writeToMemoryThroughBuffer(139, dataBuffer, true);
  //printPage(137);
  //printPage(138);
  //printPage(139);

    for (int r = 0; r < 2; r++) {
      boolean saveToMem = saveToMemory();
      if (saveToMem) {
        Serial.print("************************ Data Save to Memory - Success. ------- Run Sequence : ");
        Serial.println((r + 1), DEC);
        break;
      } else {
        Serial.print("************************ Data Save to Memory - Failed. ------- Run Sequence : ");
        Serial.println((r + 1), DEC);
      }
    }

  //saveToMemory();
  //delay(5000);
  //printPage(256, false);
  //printPage(257, false);
  //printPage(258, false);
  //printPage(259, false);
  //printPage(260, false);
  //printPage(261, false);
  //printAllMemoryPages();

  SPI.endTransaction();
}



void loop() {
  // put your main code here, to run repeatedly:
}
